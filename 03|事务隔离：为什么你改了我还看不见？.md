# 事务隔离：为什么你改了我还看不见？

> 事务就是要保证一组数据库操作，要么全部成功，要么全部失败  

## 事务的实现

* mysql中事务是在存储引擎中实现的  
* MyISAM引擎不支持事务
* InnoDB是支持事务的

## 事务特性

* A  Atomicity 原子性
* C  Consistency 一致性
* I  Isolation 隔离性
* D  Durablity 一致性

## 隔离性：事务的隔离级别

> 背景：当数据库上多个事务同时执行时，会出现脏读、不可重复读、幻读，事务的隔离级别的出现就是为了解决这些问题

1. 读未提交：一个事务未提交时，它做的变更可以被其它的事务看到；
2. 读提交：一个事务提交后，它做的变更才可以被其他事务看到；
3. 可重复读：一个事务执行过程中看到的数据跟它启动时看到的数据是一致的；
4. 串行化：对于同一行记录，写会加`写锁`(排它锁)，读会加`读锁`(非排它锁)，而当出现读写锁冲突时，后访问数据的事务必须等待前一个事务执行完成才可以继续执行；
5. mysql默认隔离级别是`可重复读`而Oracle则是`读提交`,所以对于要迁移数据库的应用要保证数据库隔离级别一致；
6. 隔离级别设置：`transaction-isolation`

```sql
show variables like 'transaction_isolation';
```

| Variable_name         | Value           |
|-----------------------|-----------------|
| transaction_isolation | REPEATABLE-READ |

## 视图

* 可重复读：事务的实现以视图的逻辑结果为准，即从事务开始到结束都使用视图中的数据
* 读未提交则无视图概念
* 串行化是通过加锁来避免并行访问

## 事务隔离的实现：回滚日志

* 在mysql中，每条记录在更新的时候都会同时记录一条混回滚操作记录到回滚日志，通过回滚就可以得到前一个状态的值
* 当查询某条记录的时候，不同时刻启动的事务会有不同的`read-view`
* 比如对于值1被修改为2，当前值是2，有事务1和事务2，事务1开启时对应`read-view1` 看到的是1，事务2开启时对应`read-view2` 看到的是2，他们之间不冲突
* 执行update的时候是当前读，会获取到实际的值
* 回滚日志的删除时机：等到没有比回滚日志更早的`read-view`的时候会被清除
* 不推荐使用`长事务`，因为长事务也就说明系统里会有很早的`read-view`也就是说回滚日志会很大，占用大量存储空间
* 长事务还会占用锁资源

<font color='#ff000'>提示：mysql5.5之前的版本，长事务提交了，回滚段被清理，文件也不会变小，必须重建整个库才能释放回滚段所占用的空间</font>
  
## 事务的启动方式

1. begin或start transaction(commit提交，rollback回滚)
2. set autocommit = 0：关闭自动提交，执行select会开启事务，直到主动执行commit或者rollback语句或者断开连接
3. 推荐使用se autocommit = 1，通过显示语句启动事务，否则会莫名其妙的产生长事务
   
<font color='#ff000'>
提示：某些客户端连接框架会默认连接成功就执行`set autocommit = 0`，从而导致查询都在事务中，而这个查询若是长连接，那么必然会出现长事务
</font>

## 查询长事务

```sql

select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## 问题：如何避免长事务对业务的影响？

* 从应用开发端来看：
  1. 确认是否使用了`set autocommit = 0`,检测方法，开启general_log,随便跑一个业务逻辑，通过general_log确认，如果使用了改为1
  2. 确认是否有不必要的只读事务（select放入事务中没必要）
  3. `set max_execution_time`控制每个语句执行最长时间，避免单个语句意外执行时间过长

* 从数据库本身来看：
  1. 监控`infomation_schema.Innodb_trx`表，设置长事务阈值,超过就报警/或者kill
  2. 推荐使用`Percona`的`pt-kill`工具
  3. 测试阶段输出所有的`general_log`，分析日志行为，提前发现问题
  4. mysql5.6及之后版本把`innodb_undo_tablespaces`设置成2（或更大），方便清理回滚段
