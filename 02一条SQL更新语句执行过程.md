# 一条 SQL 更新语句执行过程

## 更新语句执行流程

* 清空这张表的查询缓存
* 分析器通过词法解析、语法解析知道这是一条更新语句
* 优化器决定使用 ID 这个索引
* 执行器负责具体执行，找到这一行，更新
* 更新还涉及到两个日志模块：redo log（重做日志） binlog（归档日志）
* 写 redo log 和更新内存后更新流程就算完成了

## redo log

* InnoDB 引擎特有的日志
* 顺序写磁盘 速度快 WAL Write-Ahead Logging
* 解决了 IO 成本和查找成本
* redo log 大小是固定的，循环写
* 写满之后需要把记录更新到数据文件（刷盘），否则不能再执行新的的更新
* redo log 提供了数据库的`crash-safe` 能力
* `innodb_flush_log_at_trx_commit` 设置为1表示每次事务的 redo log 都会持久化到磁盘，建议开启：mysql 异常重启数据不丢失

## binlog

* server层的日志
* 归档日志，常用来做数据库备份和主从数据库同步
* `sync_bin_log` 设置为1表示每次事务的binlog都持久化到磁盘，建议开启：mysql异常重启binlog不丢失

## binlog：有了我就可以让数据库恢复到半个月内任意一秒的状态

* 中午12点误删表
* 找到最近一次全量备份
* 从备份的时间点开始，将备份的 binlog 依次取出，重新放回误删表之前的那个时刻
* 先放到临时库，按需要放回线上库

## 问题一：什么情况下一天一备比一周一备好？

> 一周一备和一天一备数据恢复时花费的时间不同，这也是方案选择的一个考虑因素

* 好处是“最长恢复时间”更短。
* 在一天一备的模式里，最坏情况下需要应用一天的 binlog。比如，你每天 0 点做一次全量备份，而要恢复出一个到昨天晚上 23 点的备份。
* 一周一备最坏情况就要应用一周的 binlog 了
* 根据业务重要性来评估RTO(目标恢复时间)成本

## redo log VS binlog

* redo log是InnoDB引擎特有的；binlog是MySQL的server层实现的，所有引擎都可以使用
* redo log是物理日志，binlog是逻辑日志
* redo log是循环写，空间固定；binlog是可以追加写，后写日志不会覆盖之前的日志
  
## 一个完整的更新语句执行流程

```sql
    update T set c = c + 1 where ID = 2
```

1. 执行器找引擎获取 ID=2 这一行；（数据页在内存这直接返回，否则需要从磁盘读入内存，另外优化器会使用 ID 索引查找）
2. 执行器拿到数据，+1后再写入新数据
3. 引擎更新数据到内存，同时写 redo log，redo log 此时状态：`prepare`
4. 执行器生成binlog，并将其写入磁盘
5. 执行器调用引擎提交事务的接口，redo log此时状态：`commit`
6. 结束

## 两阶段提交

> 将第三方系统的操作拆解成两个步骤：prepare 和 commit；
> 用于保证两个系统（应用）之间数据逻辑一致性（同时成功，同时失败）

* A 系统首先调用 B 系统修改一条数据：此时 B 系统将事务状态设置为 prepare，具体生效与否等待 A 系统通知
* A 修改自己的一条数据：可能会成功，也可能会失败
  如果成功，则调用 B 将事务提交，使得 B 的修改生效
  如果失败，B 的事务状态还保持 prepare，修改的操作不会生效

## 两阶段提交的应用：mysql更新一条数据，redo log的写入操作

> 用来保证binlog和redo log的数据一致性

* 如果不使用两阶段，会发生什么？

  先写 redo log，后写 binlog：redo log 写完，binlog 还没来得及写 mysql 崩了，由于 redo log 的 `crash-safe` 会在系统恢复时找回数据，
  但是 binlog 中没有，使用 binlog 做数据恢复或同步从库时就会少一条记录

  先写 binlog，后写 redo log：binlog 写完，redo log 还没来的及写 mysql 崩了，系统回复时 redo log 无法找回这条记录，
  而 binlog 中多出的这条数据会使得数据恢复或同步从库多一条记录

