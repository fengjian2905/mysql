# 深入浅出索引（上）

> 索引的出现就是为了提高数据查询的效率，就像书的目录一样  

* 在InnoDB中，表都是根据主键顺序以索引的形式存放的（B+树索引模型）：索引组织表
* 每一个索引在InnoDB中对应一颗B+树
* 在 InnoDB 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树

## 主键索引（聚簇索引）

叶子节点存储的是实际的数据

## 非主键索引（二级索引）

叶子节点存储的是主键的值，需再次查询主键索引树获取记录（回表）

## 主键索引 vs 非主键索引

* 从查询上看，基于非主键索引的查询需要多一次回表，即多查询一次主键索引树

## 自增主键 vs 业务主键

* B+树的索引是有序的，新增数据都会重新维护以保证其有序性
* 递增插入不会挪动其他记录，只是顺序追加，也不会导致页分裂
* 自增主键会保证顺序追加，业务主键则在无法保证顺序的情况下可能会出现页分裂
* 因为非主键索引树叶子节点存储的是主键的值，所以业务主键相比自增主键所需的存储
  空间较大
  
  ## 问题1：为什么要重建索引？
  
  索引可能会因为删除，或者分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据
  按序插入，提高页面利用率，节省空间
  
  ## 问题2：对于InnoDB表T重建索引k，重建主键索引执行如下命令有什么问题吗？
  
  * 重建索引k
  
  ```sql
    alter table T drop index  k;
    alter table T add index(k);
  ```
  
  * 重建主键
  ```sql
    alter table T drop primary key ;
    alter table T add primary key(id);
  ```
  
  * 分析：
    单看重建索引k的语句是没问题的，问题在于如果接着执行重建主键的话，
    相当于整个表重建，那么重建索引k的动作就多余了；
    
    可以使用`alter table T engine=InnoDB`来代替上面两个动作！
  
