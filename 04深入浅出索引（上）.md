# 深入浅出索引（上）

> 内容提要：主键索引 非主键索引 索引重建 主键重建

1. 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的（B+树索引模型）：索引组织表
2. 每一个索引在 InnoDB 中对应一颗 B+ 树
3. 在 InnoDB 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树

## 主键索引（聚簇索引）

叶子节点存储的是实际的数据

## 非主键索引（二级索引）

叶子节点存储的是主键的值，需再次查询主键索引树获取记录（回表）

## 主键索引 VS 非主键索引

从查询上看，基于非主键索引的查询需要多一次回表，即多查询一次主键索引树

## 主键的选取：自增主键 VS 业务主键

1. B+ 树的索引是有序的，新增数据都会重新维护以保证其有序性
2. 递增插入不会挪动其他记录，只是顺序追加，也不会导致页分裂
3. 自增主键会保证顺序追加，业务主键则在无法保证顺序的情况下可能会出现页分裂
4. 因为非主键索引树叶子节点存储的是主键的值，所以业务主键相比自增主键所需的存储
  空间较大
  
## 问题1：为什么要重建索引？
  
索引可能会因为删除，或者分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据
按序插入，提高页面利用率，节省空间
  
## 问题2：对于InnoDB表T重建索引k，重建主键索引执行如下命令有什么问题吗？
  
* 重建索引k
  
```sql
  alter table T drop index  k;
  alter table T add index(k);
```
  
* 重建主键
```sql
  alter table T drop primary key ;
  alter table T add primary key(id);
```
  
* 分析：
  单看重建索引k的语句是没问题的，问题在于如果接着执行重建主键的话，
  相当于整个表重建，那么重建索引k的动作就多余了；
  
  可以使用 `alter table T engine=InnoDB` 来代替上面两个动作！
  
