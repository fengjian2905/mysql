# 行锁

> MySQL 的行锁是在引擎层，由各个引擎自己实现的

## 两阶段锁

> InnDB事务中，行锁是在需要的时候加上的，但并不是不需要了就立刻释放，而是要等到
> 事务结束才释放。这就是两阶段锁协议！

1. 事务A
   
    ```sql
        begin;
        update t set k=k+1 where id=1;
        update t set k=k+1 where id=2;
    ```

2. 事务B
   
    ```sql
        begin;
        update t set k=k+2 where id=1;
    ```

3. 事务A
   
   ```sql
    commit;
   ```
事务 B 的update语句会被阻塞，直到事务 A 执行commit后，事务 B 才能继续执行

## 两阶段锁带给我们的现时启示

> 在一个事务中，把最可能造成锁冲突、最可能影响并发度的锁尽量往后放

## 死锁和死锁检测

**问题：**
线上 MySQL 挂了，服务器 CPU 消耗接近 100%，但整个数据库每秒就执行不到100
个事务？？


